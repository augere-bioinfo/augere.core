#' Compile an Rmarkdown report
#'
#' Compile a Rmarkdown report, typically generated from a template in a pipeline function.
#'
#' @param file String containing a path to an Rmarkdown file.
#' @param env Environment in which the R code is to be evaluated.
#' @param skip.chunks Character vector of the names of Rmarkdown chunks to skip.
#' @param contents List or character vector containing the contents of \code{file}.
#' Note that \code{file} must still be supplied, see Details.
#'
#' @return Code chunks from \code{file} are compiled, typically populating \code{env} with new variables.
#' \code{NULL} is invisibly returned.
#'
#' @details
#' This function leverages the input cache populated by \code{\link{processInputCommands}}.
#' If a chunk contains code generated by \code{\link{processInputCommands}},
#' \code{compileReport} will attempt to load the corresponding object from cache instead of re-running the associated code.
#' This avoids using more time/memory to create an object that is already available in the R session.
#'
#' If no existing graphics devices are enabled, any plots will be directed to a null device during code chunk evaluation.
#' This prevents a flash of multiple images on the default graphics device during pipeline execution.
#'
#' \code{compileReport} automatically changes the working directory to that of \code{file}.
#' This is consistent with the behavior of \pkg{knitr} and ensures that any relative paths in \code{file} are respected.
#' If \code{contents} is supplied, the actual \code{file} need not exist but its directory should be accessible.
#'
#' @seealso
#' \code{\link{processInputCommands}}, to define the input objects in the Rmarkdown file.
#'
#' \code{\link{extractChunks}} and \code{\link{evaluateChunks}}, to extract the R code chunks and evaluate them, respectively.
#'
#' @author Aaron Lun
#' @examples
#' tmp <- tempfile()
#' dir.create(tmp)
#' path <- file.path(tmp, "test.Rmd")
#' 
#' write("```{r}
#' res <- data.frame(foo=1:5, bar=LETTERS[2:6])
#' write.csv(res, file='results.csv')
#' ```", file=path)
#' 
#' env <- new.env()
#' compileReport(path, env)
#' env$res
#' 
#' list.files(dirname(path))
#'
#' @export
#' @importFrom grDevices pdf dev.off dev.list
compileReport <- function(file, env, skip.chunks=NULL, contents=NULL) {
    if (is.null(contents)) {
        lines <- readLines(file)
    } else {
        lines <- unlist(strsplit(unlist(contents), "\n"))
    }
    chunks <- extractChunks(lines)
    chunk.names <- names(chunks)

    for (i in seq_along(chunks)) {
        current <- chunks[[i]]

        if (!is.null(chunk.names)) {
            if (chunk.names[i] %in% skip.chunks) {
                current <- character(0)
            }
        }

        # Avoid re-running code to generate objects that are already present in the R session.
        to.replace <- grep(.input_tag, current, fixed=TRUE)
        if (length(to.replace)) {
            current[to.replace] <- sub(" local\\(\\{.*\\(([0-9]+)\\)", " augere.core:::.local(\\1, {", current[to.replace])
        }

        chunks[[i]] <- current
    }

    if (is.null(dev.list())) {
        pdf(file=NULL)
        on.exit(dev.off(), add=TRUE)
    }

    # Compile the report in the file's working directory, so that any relative file paths are respected.
    oldwd <- getwd()
    setwd(dirname(file))
    on.exit(setwd(oldwd), after=FALSE, add=TRUE)

    evaluateChunks(chunks, env)
}

.local <- function(i, ...) {
    .pop_input_cache(i)
}
